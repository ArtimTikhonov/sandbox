# =============================================================================
# МУЛЬТИСТЕЙДЖ DOCKERFILE ДЛЯ МИКРОСЕРВИСНОЙ АРХИТЕКТУРЫ + ФРОНТЕНД
# =============================================================================
# Этот Dockerfile использует мультистейдж подход для создания оптимизированных
# образов. Один файл - четыре разных сервиса на выходе.

# =============================================================================
# ЭТАП 1: СБОРКА BACKEND (BUILD STAGE)
# =============================================================================
# Используем образ с Maven и Java 24 для компиляции наших приложений
FROM maven:3.9-eclipse-temurin-24 AS build

# Аргумент для принудительной пересборки - если изменится, Docker пересоберёт образ
# Можно передать при сборке: docker build --build-arg REBUILD_DATE=$(date)
ARG REBUILD_DATE=unknown

# Устанавливаем рабочую директорию внутри контейнера
WORKDIR /app

# Создаём файл-маркер с датой сборки - помогает отследить когда образ собирался
# Этот трюк заставляет Docker пересобирать образ при изменении REBUILD_DATE
RUN echo "Rebuild date: $REBUILD_DATE" > rebuild_marker.txt

# =============================================================================
# КОПИРОВАНИЕ И ПОДГОТОВКА ЗАВИСИМОСТЕЙ
# =============================================================================
# Сначала копируем только pom.xml файлы - это позволяет кешировать зависимости
# Если код изменится, но зависимости останутся те же - Maven их не перекачает

# Копируем родительский pom.xml
COPY pom.xml .

# Копируем pom.xml каждого модуля
COPY service-one/pom.xml service-one/
COPY service-two/pom.xml service-two/
COPY api-gateway/pom.xml api-gateway/

# Загружаем все зависимости заранее (offline режим)
# -B = batch режим (без интерактивных вопросов)
# Это создаёт отдельный слой в Docker образе для зависимостей
RUN mvn dependency:go-offline -B

# =============================================================================
# КОПИРОВАНИЕ ИСХОДНОГО КОДА И СБОРКА BACKEND
# =============================================================================
# Теперь копируем исходный код каждого сервиса
COPY service-one/src service-one/src
COPY service-two/src service-two/src
COPY api-gateway/src api-gateway/src

# Выполняем полную сборку проекта
# clean = очищаем предыдущие артефакты
# package = компилируем и упаковываем в JAR файлы
# -DskipTests = пропускаем тесты для ускорения сборки
RUN mvn clean package -DskipTests

# =============================================================================
# ЭТАП 2: СБОРКА FRONTEND
# =============================================================================
FROM node:18-alpine AS frontend-build

# Устанавливаем рабочую директорию
WORKDIR /app

# Копируем package.json и package-lock.json для кеширования зависимостей
COPY frontend/package*.json ./

# Устанавливаем зависимости
RUN npm install

# Копируем исходный код фронтенда
COPY frontend/ .

# Собираем production build
RUN npm run build

# =============================================================================
# ЭТАП 3: RUNTIME ОБРАЗ ДЛЯ FRONTEND
# =============================================================================
FROM nginx:alpine AS frontend

# Удаляем дефолтную конфигурацию nginx
RUN rm /etc/nginx/conf.d/default.conf

# Копируем кастомную конфигурацию nginx
COPY frontend/nginx.conf /etc/nginx/conf.d/

# Копируем собранное React приложение из этапа сборки
COPY --from=frontend-build /app/build /usr/share/nginx/html

# Открываем порт 80
EXPOSE 80

# Запускаем nginx
CMD ["nginx", "-g", "daemon off;"]

# =============================================================================
# ЭТАП 4: RUNTIME ОБРАЗ ДЛЯ SERVICE-ONE
# =============================================================================
# Создаём лёгкий образ только с JRE (без Maven и исходников)
FROM eclipse-temurin:24-jre AS service-one

# Устанавливаем рабочую директорию
WORKDIR /app

# Копируем только готовый JAR файл из этапа сборки
# --from=build указывает откуда копировать (из предыдущего этапа)
# *.jar - копируем любой JAR файл из target директории
COPY --from=build /app/service-one/target/*.jar app.jar

# Открываем порт 8080 для внешних подключений
EXPOSE 8080

# Команда запуска приложения
# java -jar app.jar - стандартный способ запуска Spring Boot приложения
ENTRYPOINT ["java", "-jar", "app.jar"]

# =============================================================================
# ЭТАП 5: RUNTIME ОБРАЗ ДЛЯ SERVICE-TWO
# =============================================================================
# Аналогично service-one, но для второго сервиса
FROM eclipse-temurin:24-jre AS service-two
WORKDIR /app
COPY --from=build /app/service-two/target/*.jar app.jar

# Service-two работает на порту 8081
EXPOSE 8081
ENTRYPOINT ["java", "-jar", "app.jar"]

# =============================================================================
# ЭТАП 6: RUNTIME ОБРАЗ ДЛЯ API-GATEWAY
# =============================================================================
# Третий сервис - API Gateway (шлюз)
FROM eclipse-temurin:24-jre AS api-gateway
WORKDIR /app
COPY --from=build /app/api-gateway/target/*.jar app.jar

# API Gateway работает на порту 8000 (главная точка входа)
EXPOSE 8000
ENTRYPOINT ["java", "-jar", "app.jar"]

# =============================================================================
# ИТОГ: ОДИН DOCKERFILE - ЧЕТЫРЕ ОБРАЗА
# =============================================================================
# При сборке Docker создаст:
# 1. docker build --target frontend -> образ фронтенда с nginx
# 2. docker build --target service-one -> образ первого сервиса
# 3. docker build --target service-two -> образ второго сервиса
# 4. docker build --target api-gateway -> образ API шлюза
#
# Все образы используют общие этапы сборки, что экономит время и место